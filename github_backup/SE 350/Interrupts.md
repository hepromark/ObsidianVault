### Overview

Software interrupts changes regular processor task sequencing, forcing processor to process the interrupt first before continuing its current task.
Commonly used when:
- working with I/O devices, where the processor will have to pause to wait for the device to complete if no interrupts
- allowing the OS to regain control of system operation (away from application operation)

#### Classes of Interrupts

| Name             | Description                                                                                                                                                                                                                               |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Program          | Generated by some condition arising from instruction execution:<br>- Arithmetic overflow<br>- Division by 0<br>- Trying to execute illegal machine instructions (ex: privileged instructions)<br>- Reference outside allowed memory space |
| Timer            | Generated by a timer within the processor<br>- Lets OS perform functions on regular basis                                                                                                                                                 |
| I/O              | Generated by an I/O controller:<br>- Signal completion of an operation<br>- Signal variety of error conditions                                                                                                                            |
| Hardware Failure | Generated by a failure:<br>- Power failure<br>- Memory parity failure                                                                                                                                                                     |

### Program Flow of Control
1. No interrupt
- At every `WRITE`, the processor needs to wait (for device I/O operation)
- $n$ writes = $n$ waits
![[Pasted image 20250108182018.png]]

2. Short I/O wait
- At each write, processor executes (4) and instead of waiting for device I/O, processor returns back to program
- 'Short' = device I/O assumed to be complete (and interrupt happens) before the main program needs to wait
	- Processor has no wait

![[Pasted image 20250108182856.png]]

3. Long I/O wait
- Same as short I/O wait, but main program MAY need to wait for the interrupt call before continuing
	- Ex: another `WRITE` to the same device
	- Ex: main program needs to operate on the `READ` data 
- These conditions may have existed in short case, but I/O operation assumed faster then so no processor wait needed unlike in this long case

![[Pasted image 20250108182838.png]]

### Instruction Cycle with Interrupts

![[Pasted image 20250108183309.png]]
Processor checks for interrupts, and if interrupt:
1. Suspend execution of program & store program snapshot on the stack
2. Execute interrupt-handler routine
3. Pop program snapshot from stack & resume execution of program
Note: ^ is most simple, doesn't account for nests and priorities

### Simple Interrupt Processing
![[Pasted image 20250108183740.png]]

#### Storing a snapshot

Initial state:
- PC points at the current program instruction, i.e. $N$
- General registers contains program-specific instructions
- SP points at current top of stack, i.e. $T$

1. Device / system hardware issues interrupt
2. Processor finishes execution of current instruction at $N$
3. Processor acknowledges interrupt
4. Processor pushes PC, PSW (Program Status Word) onto the stack
5. Processor loads new value onto PC based on interrupt

6. Registers: R0 -> R3, R12, LR, PC, PSW stored on the stack
7. Processor start processing the interrupt instructions at $Y$, pointed to by PC
8. PC reaches the end of interrupt instructions, $Y + L + 1$
9. Old register data is popped from the stack back into registers.
10. Old PSW and PC data restored.

### Special Registers

Process Stack Pointer (PSP) and Main Stack Pointer (MSP)
- 2 'banked' SP versions
	- At any point in time, R13 represents either PSP or MSP
- Handler mode: MSP
- Thread mode: MSP or PSP

Program Status Register (PSR)
- Software can only **Read** PSR
- Processor can modify register & restore from memory when entering / existing an interrupt
- Stores condition flags
	- Bits 0 - 8: Interrupt Program Status
		- 0000000: thread mode
		- >0: handler mode, exact value gives type of interrupt
	- Bit 24: Thumb mode

Control Register
- Bit 1: where MSP (0) or PSP (1) used
- Bit 0: Thread mode is unprivileged (0) or privileged (1)

### Privileged Mode

Privileged mode allows processor to execute *privileged* instructions
- These instructions may operate on special *privileged* registers that are otherwise inaccessible
- `MRS dst, spec_reg` - copies special reg value into dst register
- `MSR spec_reg, src`  - copies src register value into special reg
